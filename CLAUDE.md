# Project Instructions

## General guidelines
Aim of current status of project is to have a _correct_ working pipeline.
Performance optimization will come later.  At the moment, priority is
correctenss _and_ code simplicity. If an implementation is simpler but probably
slower we prefer the simpler. However, performance shouldn't be ridiculously
bad, so if you have a simple implementation that is also reasonably efficient,
go for it.
*NEVER* sacrifice correctness. If its totally needed, ask the user for feedback.
*DON'T* fail silently or return "error" values. As soon as an error or ill condition
is detected, fail loudly with an exception.

## Slang Library Context Optimization

This project uses the slang library (external/slang/) for SystemVerilog
parsing. To optimize context window usage, follow these rules:

### Allowed slang files (read freely)
- `external/slang/include/slang/syntax/SyntaxTree.h`
- `external/slang/include/slang/syntax/SyntaxVisitor.h`
- `external/slang/scripts/syntax.txt` — **grep for specific types, never read fully** (~2400 lines)

### Never read (unless explicitly requested)
- Generated files (`AllSyntax.h`, `SyntaxKind.h`) — use the mapping rules below instead
- Slang implementation files (`*.cpp`), test files, documentation files
- Any other file under `external/slang/` — ask user first

### How syntax.txt maps to C++ code

Generated by `external/slang/scripts/syntax_gen.py` into
`build/external/slang/source/slang/syntax/`.

**Naming:** append `Syntax` for class, bare name for enum.
- `ModuleDeclaration` -> class `ModuleDeclarationSyntax`, enum `SyntaxKind::ModuleDeclaration`

**Inheritance:** `base=X` -> inherits `XSyntax`. No base -> inherits `SyntaxNode`.
`final=false` -> abstract base class, no own SyntaxKind.

**Members:**

| syntax.txt               | C++ type                              |
|--------------------------|---------------------------------------|
| `token x`                | `Token x;`                            |
| `tokenlist x`            | `TokenList x;`                        |
| `Foo x`                  | `not_null<FooSyntax*> x;`             |
| `Foo? x`                 | `FooSyntax* x;` (nullable)            |
| `list<Foo> x`            | `SyntaxList<FooSyntax> x;`            |
| `separated_list<Foo> x`  | `SeparatedSyntaxList<FooSyntax> x;`   |

**multiKind:** when `multiKind=true`, the `kindmap<Name>` block lists
the SyntaxKind enum values that all share that struct. Constructor takes
`SyntaxKind kind`; check `node.kind` to distinguish.

**Visitor:** implement `handle(const XSyntax&)` in a
`SyntaxVisitor<Derived>` subclass. For multiKind types, one handle
catches all kinds in the kindmap.

**Common abstract bases (final=false):**
`ExpressionSyntax`, `DataTypeSyntax` (extends Expression),
`StatementSyntax` (has label + attributes), `MemberSyntax` (has attributes),
`TimingControlSyntax`, `NameSyntax` (extends Expression).

## Testing changes

When testing for a change, only check that it builds. To run the compiler program (`ir_builder`) ask permission for the user, only do it if needed.

## How to respond

In this project I intend for you to act in two ways:

* Teacher mode: on this case, I want to learn by doing apart from getting the project done. Guide me through the solutions, offer insight, and hints/guidance. Don't provide fully working solution nor edit files. Help me get to the solution
* Productive mode: here act as normal, help me get the request done.

You should default to productive mode and only enter teacher mode when asked.
